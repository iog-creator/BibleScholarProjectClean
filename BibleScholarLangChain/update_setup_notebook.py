#!/usr/bin/env python3
"""
BibleScholarLangChain Setup Notebook Generator
Generates comprehensive setup.ipynb with modular, maintainable structure

Copyright (c) 2025 BibleScholarLangChain Project

Licensed under the BibleScholarLangChain Personal Biblical Use License.
This software is free for personal biblical study, research, and educational use.
Commercial use requires written permission and payment of licensing fees.
See LICENSE file for full terms.
"""
import json
import os
import sys
from datetime import datetime
from typing import Dict, List, Any

# Configuration Constants
NOTEBOOK_PATH = "setup.ipynb"
PROJECT_NAME = "BibleScholarLangChain"
PROJECT_VERSION = "v2.0.0"
PYTHON_VERSION = "3.11.0"

class NotebookGenerator:
    """Handles notebook generation with modular sections"""
    
    def __init__(self):
        self.cells = []
        self.current_step = 1
        
    def create_markdown_cell(self, content: str) -> Dict[str, Any]:
        """Create a markdown cell with the given content"""
        return {
            "cell_type": "markdown",
            "metadata": {},
            "source": content.split("\n")
        }

    def create_code_cell(self, content: str, execution_count: int = None) -> Dict[str, Any]:
        """Create a code cell with the given content"""
        return {
            "cell_type": "code",
            "execution_count": execution_count,
            "metadata": {},
            "outputs": [],
            "source": content.split("\n")
        }
    
    def add_section_header(self, title: str, description: str = ""):
        """Add a section header with optional description"""
        content = f"## Step {self.current_step}: {title}\n\n{description}" if description else f"## Step {self.current_step}: {title}"
        self.cells.append(self.create_markdown_cell(content))
        self.current_step += 1
    
    def add_markdown(self, content: str):
        """Add markdown content"""
        self.cells.append(self.create_markdown_cell(content))
    
    def add_code(self, content: str):
        """Add code content"""
        self.cells.append(self.create_code_cell(content))

class ContentSections:
    """Contains all content sections for the notebook"""
    
    @staticmethod
    def get_header_content() -> str:
        """Get the main header content"""
        return f"""# {PROJECT_NAME} Setup - Enhanced Edition

## 🎯 **COMPREHENSIVE BIBLE STUDY PLATFORM**
This notebook sets up `{PROJECT_NAME}` with **95%+ database utilization** and comprehensive Biblical analysis capabilities.

### **🚀 Core Capabilities**
1. **Multi-Language Original Text Analysis**:
   - **Hebrew OT**: 283,717 words with complete morphology
   - **Greek NT**: 22,266 words with complete morphology
   - **Combined Strong's**: Hebrew H0001-H8674 + Greek G0001-G5624
   - **Total Coverage**: 305,983 original language words

2. **Complete Translation Coverage**:
   - **ASV**: 31,103 verses (American Standard Version)
   - **YLT**: 31,102 verses (Young's Literal Translation)
   - **KJV**: 31,100 verses (King James Version)
   - **Total**: 124,305+ verses across all translations

3. **Advanced Semantic Search**:
   - **BGE-M3 Embeddings**: 1024-dimensional vectors (110,592 records)
   - **Nomic Embeddings**: 768-dimensional vectors (116,566 records)
   - **Total Embeddings**: 227,158 vector records

4. **Server Infrastructure**:
   - **API Server** (port 5200): Enhanced API with TAHOT integration
   - **Web UI Server** (port 5300): Enhanced web interface
   - **LM Studio Integration** (port 1234): AI-powered analysis
   - **PostgreSQL Database** (port 5432): Complete Bible database

## 📋 **LICENSE NOTICE**
**🔒 Personal Biblical Use Only** - This software is licensed for **free personal biblical study, research, and educational use only**. Commercial use requires written permission and payment of licensing fees.

**For commercial licensing inquiries, please contact: mccoyb00@duck.com**

**Generated by**: `update_setup_notebook.py` - Edit that script to update this notebook."""

    @staticmethod
    def get_environment_setup() -> str:
        """Get environment setup code"""
        return """# Environment Setup and Project Configuration
import os
import sys
import subprocess
import json
from pathlib import Path

# Project configuration
PROJECT_PATH = "C:/Users/mccoy/Documents/Projects/Projects/CursorMCPWorkspace/BibleScholarLangChain"
VENV_NAME = "BSPclean"
PYTHON_VERSION = "3.11.0"

# Ensure we're in the right directory
os.chdir(PROJECT_PATH)
print(f"Working directory: {os.getcwd()}")

# Create project structure
directories = [
    "src/api",
    "src/database", 
    "src/utils",
    "static/css",
    "static/js",
    "templates",
    "logs",
    "scripts",
    "docs",
    "config"
]

for directory in directories:
    Path(directory).mkdir(parents=True, exist_ok=True)
    print(f"✓ Created directory: {directory}")

print("\\n✅ Project structure created successfully")"""

    @staticmethod
    def get_database_setup() -> str:
        """Get database setup code"""
        return """# Database Configuration and Connection
import psycopg
from psycopg.rows import dict_row

# Database connection configuration
DB_CONFIG = {
    "host": "127.0.0.1",
    "port": 5432,
    "database": "bible_db",
    "user": "postgres",
    "password": "password"
}

def test_database_connection():
    \"\"\"Test database connection and verify key tables\"\"\"
    try:
        conn_str = f"postgresql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@{DB_CONFIG['host']}:{DB_CONFIG['port']}/{DB_CONFIG['database']}"
        with psycopg.connect(conn_str, row_factory=dict_row) as conn:
            with conn.cursor() as cursor:
                # Test connection
                cursor.execute("SELECT version()")
                version = cursor.fetchone()
                print(f"✅ PostgreSQL Version: {version['version']}")
                
                # Check key tables
                tables_to_check = [
                    "hebrew_ot_words",
                    "greek_nt_words", 
                    "verses",
                    "verse_embeddings",
                    "versification_mappings"
                ]
                
                for table in tables_to_check:
                    try:
                        cursor.execute(f"SELECT COUNT(*) as count FROM {table}")
                        count = cursor.fetchone()
                        print(f"✅ {table}: {count['count']:,} records")
                    except Exception as e:
                        print(f"❌ {table}: Error - {e}")
                        
        return True
        
    except Exception as e:
        print(f"❌ Database connection failed: {e}")
        return False

# Test the connection
if test_database_connection():
    print("\\n✅ Database connection and tables verified")
else:
    print("\\n❌ Database connection failed - check PostgreSQL service")"""

    @staticmethod
    def get_server_setup() -> str:
        """Get server setup code"""
        return """# Server Configuration and Startup Scripts
import os
import subprocess
import json
from pathlib import Path

def create_startup_script():
    \"\"\"Create enhanced start_servers.bat script\"\"\"
    
    startup_script = '''@echo off
echo ========================================
echo BibleScholarLangChain Server Startup
echo Enhanced Edition with License Protection
echo ========================================

REM Kill existing processes
echo Stopping existing servers...
taskkill /F /IM python.exe 2>nul
netstat -ano | findstr :5200 | for /f "tokens=5" %%a in ('findstr TCP') do taskkill /PID %%a /F 2>nul
netstat -ano | findstr :5300 | for /f "tokens=5" %%a in ('findstr TCP') do taskkill /PID %%a /F 2>nul

REM Change to BibleScholarLangChain directory
cd /d "%~dp0\\BibleScholarLangChain"
echo Current directory: %CD%

REM Activate virtual environment
echo Activating BSPclean environment...
call ..\\BSPclean\\Scripts\\activate.bat

REM Start Enhanced API Server (port 5200)
echo Starting Enhanced API Server on port 5200...
start "API Server" cmd /k "python src/api/api_app.py"
timeout /t 8 /nobreak >nul

REM Test API Server
curl -s http://localhost:5200/health >nul
if %errorlevel% equ 0 (
    echo ✅ Enhanced API Server: OPERATIONAL
) else (
    echo ❌ Enhanced API Server: FAILED TO START
)

REM Start Enhanced Web UI Server (port 5300)  
echo Starting Enhanced Web UI Server on port 5300...
start "Web UI Server" cmd /k "python web_app.py"
timeout /t 8 /nobreak >nul

REM Test Web UI Server
curl -s http://localhost:5300/health >nul
if %errorlevel% equ 0 (
    echo ✅ Enhanced Web UI Server: OPERATIONAL
) else (
    echo ❌ Enhanced Web UI Server: FAILED TO START
)

echo.
echo ========================================
echo Server Startup Complete
echo ========================================
echo Enhanced API Server: http://localhost:5200
echo Enhanced Web UI: http://localhost:5300
echo Press any key to exit...
pause >nul
'''
    
    # Write to root directory (parent of BibleScholarLangChain)
    root_path = Path("..").resolve()
    script_path = root_path / "start_servers.bat"
    
    with open(script_path, 'w', encoding='utf-8') as f:
        f.write(startup_script)
    
    print(f"✅ Created startup script: {script_path}")
    return str(script_path)

def create_config_files():
    \"\"\"Create configuration files\"\"\"
    
    # Create .env file
    env_content = '''# BibleScholarLangChain Configuration
# Personal Biblical Use License - mccoyb00@duck.com

# Server Configuration
API_PORT=5200
WEB_PORT=5300
DEBUG=True

# Database Configuration  
DB_HOST=127.0.0.1
DB_PORT=5432
DB_NAME=bible_db
DB_USER=postgres
DB_PASSWORD=password

# LM Studio Configuration
LM_STUDIO_URL=http://localhost:1234
LM_STUDIO_MODEL=meta-llama-3.1-8b-instruct

# Cache Configuration
ENABLE_CACHE=1
CACHE_TIMEOUT=300

# Security
SECRET_KEY=your_secret_key_change_in_production
'''
    
    with open('.env', 'w') as f:
        f.write(env_content)
    print("✅ Created .env configuration file")
    
    # Create config.json
    config = {
        "project_name": "BibleScholarLangChain",
        "version": "2.0.0",
        "license": "Personal Biblical Use Only",
        "contact": "mccoyb00@duck.com",
        "servers": {
            "api": {"port": 5200, "host": "localhost"},
            "web": {"port": 5300, "host": "localhost"},
            "lm_studio": {"port": 1234, "host": "localhost"}
        },
        "database": {
            "host": "127.0.0.1",
            "port": 5432,
            "name": "bible_db",
            "tables": {
                "hebrew_words": "hebrew_ot_words",
                "greek_words": "greek_nt_words", 
                "verses": "verses",
                "embeddings": "verse_embeddings"
            }
        }
    }
    
    with open('config/config.json', 'w') as f:
        json.dump(config, f, indent=2)
    print("✅ Created config/config.json")

# Create the scripts and configuration
script_path = create_startup_script()
create_config_files()

print("\\n✅ Server configuration complete")
print(f"Startup script: {script_path}")"""

    @staticmethod
    def get_api_server_code() -> str:
        """Get API server creation code"""
        return '''# Enhanced API Server with License Protection
import os
from pathlib import Path

def create_enhanced_api_server():
    """Create the enhanced API server with proper licensing"""
    
    api_code = """#!/usr/bin/env python3
\"\"\"
Enhanced API server for BibleScholarLangChain with comprehensive data integration
Serves on port 5200 with TAHOT integration and license protection

Copyright (c) 2025 BibleScholarLangChain Project

Licensed under the BibleScholarLangChain Personal Biblical Use License.
This software is free for personal biblical study, research, and educational use.
Commercial use requires written permission and payment of licensing fees.
See LICENSE file for full terms.
\"\"\"
from flask import Flask, jsonify, request
from flask_cors import CORS
import psycopg
from psycopg.rows import dict_row
import logging
from datetime import datetime

app = Flask(__name__)
CORS(app)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_db_connection():
    \"\"\"Get database connection with error handling\"\"\"
    try:
        return psycopg.connect(
            "postgresql://postgres:password@127.0.0.1:5432/bible_db",
            row_factory=dict_row
        )
    except Exception as e:
        logger.error(f"Database connection failed: {e}")
        return None

@app.route('/health')
def health():
    \"\"\"Enhanced health check with database validation\"\"\"
    db_status = 'disconnected'
    integration_status = {}
    
    try:
        conn = get_db_connection()
        if conn:
            with conn.cursor() as cursor:
                cursor.execute('SELECT 1')
                db_status = 'connected'
                
                # Test core tables
                tables = {
                    'hebrew_words': 'hebrew_ot_words',
                    'greek_words': 'greek_nt_words', 
                    'verses': 'verses',
                    'embeddings': 'verse_embeddings'
                }
                
                for key, table in tables.items():
                    try:
                        cursor.execute(f'SELECT COUNT(*) as count FROM {table}')
                        integration_status[key] = cursor.fetchone()['count']
                    except Exception as e:
                        integration_status[key] = f'Error: {e}'
            
            conn.close()
    except Exception as e:
        logger.error(f'Health check failed: {e}')
    
    return jsonify({
        'status': 'Enhanced API server operational',
        'database_status': db_status,
        'integration_status': integration_status,
        'timestamp': datetime.now().isoformat(),
        'server': 'Enhanced API Server (port 5200)',
        'license': 'Personal Biblical Use Only',
        'contact': 'mccoyb00@duck.com'
    })

@app.route('/')
def index():
    \"\"\"API information endpoint\"\"\"
    return jsonify({
        'name': 'BibleScholarLangChain Enhanced API',
        'version': '2.0.0',
        'port': 5200,
        'license': 'Personal Biblical Use Only - mccoyb00@duck.com',
        'endpoints': [
            '/health - Health check',
            '/api/search - Search functionality',
            '/api/lexicon - Lexicon analysis'
        ]
    })

@app.route('/api/search')
def api_search():
    \"\"\"Basic search functionality\"\"\"
    query = request.args.get('q', '')
    if not query:
        return jsonify({'error': 'Query parameter required'}), 400
    
    try:
        conn = get_db_connection()
        if not conn:
            return jsonify({'error': 'Database connection failed'}), 500
            
        with conn.cursor() as cursor:
            cursor.execute(
                "SELECT book, chapter, verse, text FROM verses WHERE text ILIKE %s LIMIT 10",
                (f'%{query}%',)
            )
            results = cursor.fetchall()
        
        conn.close()
        return jsonify({'results': results, 'count': len(results)})
        
    except Exception as e:
        logger.error(f'Search error: {e}')
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("Starting Enhanced API Server on port 5200...")
    print("License: Personal Biblical Use Only")
    print("Contact: mccoyb00@duck.com")
    app.run(host='0.0.0.0', port=5200, debug=True, use_reloader=False)
\"\"\"
    
    # Create the API server file
    api_path = Path("src/api/api_app.py")
    api_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(api_path, 'w', encoding='utf-8') as f:
        f.write(api_code)
    
    print(f"✅ Created enhanced API server: {api_path}")
    return str(api_path)

# Create the API server
api_path = create_enhanced_api_server()
print(f"Enhanced API server created: {api_path}")'''

    @staticmethod
    def get_web_server_code() -> str:
        """Get web server creation code"""
        return '''# Enhanced Web UI Server with License Protection
import os
from pathlib import Path

def create_enhanced_web_server():
    """Create the enhanced web server with proper licensing"""
    
    web_code = """#!/usr/bin/env python3
\"\"\"
Enhanced Web UI server for BibleScholarLangChain
Serves on port 5300 with comprehensive Bible study features and license protection

Copyright (c) 2025 BibleScholarLangChain Project

Licensed under the BibleScholarLangChain Personal Biblical Use License.
This software is free for personal biblical study, research, and educational use.
Commercial use requires written permission and payment of licensing fees.
See LICENSE file for full terms.
\"\"\"
from flask import Flask, render_template, request, jsonify
import requests
import logging
from datetime import datetime

app = Flask(__name__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration
API_BASE_URL = 'http://localhost:5200'

@app.route('/')
def index():
    \"\"\"Home page with license notice\"\"\"
    return render_template('index.html')

@app.route('/health')
def health():
    \"\"\"Health check for web server\"\"\"
    # Test API connection
    api_status = 'disconnected'
    try:
        response = requests.get(f'{API_BASE_URL}/health', timeout=5)
        if response.status_code == 200:
            api_status = 'connected'
    except Exception as e:
        logger.error(f'API health check failed: {e}')
    
    return jsonify({
        'status': 'Enhanced Web UI operational',
        'api_status': api_status,
        'timestamp': datetime.now().isoformat(),
        'server': 'Enhanced Web UI (port 5300)',
        'license': 'Personal Biblical Use Only',
        'contact': 'mccoyb00@duck.com'
    })

@app.route('/search')
def search():
    \"\"\"Search interface\"\"\"
    return render_template('search.html')

@app.route('/api/search')
def proxy_search():
    \"\"\"Proxy search requests to API server\"\"\"
    query = request.args.get('q', '')
    try:
        response = requests.get(f'{API_BASE_URL}/api/search', params={'q': query})
        return response.json()
    except Exception as e:
        logger.error(f'Search proxy error: {e}')
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    print("Starting Enhanced Web UI Server on port 5300...")
    print("License: Personal Biblical Use Only")
    print("Contact: mccoyb00@duck.com")
    app.run(host='0.0.0.0', port=5300, debug=True, use_reloader=False)
\"\"\"
    
    # Create the web server file
    web_path = Path("web_app.py")
    
    with open(web_path, 'w', encoding='utf-8') as f:
        f.write(web_code)
    
    print(f"✅ Created enhanced web server: {web_path}")
    
    # Create basic HTML template
    template_dir = Path("templates")
    template_dir.mkdir(exist_ok=True)
    
    index_html = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BibleScholarLangChain - Personal Biblical Use</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
    <div class="container mt-4">
        <header class="text-center mb-4">
            <h1>BibleScholarLangChain</h1>
            <p class="lead">Comprehensive Bible Study Platform</p>
            <div class="alert alert-info">
                <strong>🔒 Personal Biblical Use Only</strong><br>
                Licensed for free personal biblical study, research, and educational use.<br>
                Commercial use requires permission. Contact: mccoyb00@duck.com
            </div>
        </header>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5>Bible Search</h5>
                    </div>
                    <div class="card-body">
                        <a href="/search" class="btn btn-primary">Search Bible Verses</a>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5>System Status</h5>
                    </div>
                    <div class="card-body">
                        <button class="btn btn-info" onclick="checkHealth()">Check System Health</button>
                        <div id="health-status" class="mt-2"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        function checkHealth() {
            fetch('/health')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('health-status').innerHTML = 
                        `<div class="alert alert-success">System Status: ${data.status}</div>`;
                })
                .catch(error => {
                    document.getElementById('health-status').innerHTML = 
                        `<div class="alert alert-danger">Error: ${error}</div>`;
                });
        }
    </script>
</body>
</html>"""
    
    with open(template_dir / "index.html", 'w', encoding='utf-8') as f:
        f.write(index_html)
    
    print("✅ Created basic HTML templates")
    
    return str(web_path)

# Create the web server
web_path = create_enhanced_web_server()
print(f"Enhanced web server created: {web_path}")'''

    @staticmethod
    def get_testing_code() -> str:
        """Get testing and validation code"""
        return '''# System Testing and Validation
import requests
import time
import json

def test_system_health():
    """Test all system components"""
    
    print("\\n" + "="*50)
    print("SYSTEM HEALTH CHECK")
    print("="*50)
    
    # Test API Server
    try:
        response = requests.get("http://localhost:5200/health", timeout=10)
        if response.status_code == 200:
            data = response.json()
            print("✅ Enhanced API Server: OPERATIONAL")
            print(f"   Database: {data.get('database_status', 'unknown')}")
        else:
            print(f"❌ Enhanced API Server: HTTP {response.status_code}")
    except Exception as e:
        print(f"❌ Enhanced API Server: {e}")
    
    # Test Web UI Server
    try:
        response = requests.get("http://localhost:5300/health", timeout=10)
        if response.status_code == 200:
            data = response.json()
            print("✅ Enhanced Web UI Server: OPERATIONAL")
            print(f"   API Connection: {data.get('api_status', 'unknown')}")
        else:
            print(f"❌ Enhanced Web UI Server: HTTP {response.status_code}")
    except Exception as e:
        print(f"❌ Enhanced Web UI Server: {e}")
    
    # Test Database Search
    try:
        response = requests.get("http://localhost:5200/api/search?q=love", timeout=10)
        if response.status_code == 200:
            data = response.json()
            count = data.get('count', 0)
            print(f"✅ Database Search: OPERATIONAL ({count} results for 'love')")
        else:
            print(f"❌ Database Search: HTTP {response.status_code}")
    except Exception as e:
        print(f"❌ Database Search: {e}")
    
    print("="*50)
    print("License: Personal Biblical Use Only")
    print("Contact: mccoyb00@duck.com")
    print("="*50)

# Run the health check
test_system_health()

# Create test script file
test_script = """#!/usr/bin/env python3
\"\"\"
System test script for BibleScholarLangChain
Tests all components and generates health report
\"\"\"
import requests
import json
from datetime import datetime

def run_comprehensive_test():
    results = {
        'timestamp': datetime.now().isoformat(),
        'tests': {}
    }
    
    # Test all endpoints
    endpoints = [
        ('API Health', 'http://localhost:5200/health'),
        ('Web Health', 'http://localhost:5300/health'),
        ('API Search', 'http://localhost:5200/api/search?q=love'),
        ('Web Index', 'http://localhost:5300/')
    ]
    
    for name, url in endpoints:
        try:
            response = requests.get(url, timeout=5)
            results['tests'][name] = {
                'status': 'PASS' if response.status_code == 200 else 'FAIL',
                'status_code': response.status_code,
                'response_size': len(response.content)
            }
        except Exception as e:
            results['tests'][name] = {
                'status': 'ERROR',
                'error': str(e)
            }
    
    # Save results
    with open('logs/test_results.json', 'w') as f:
        json.dump(results, f, indent=2)
    
    # Print summary
    print("\\nTest Results:")
    for name, result in results['tests'].items():
        status = result['status']
        print(f"  {name}: {status}")
    
    return results

if __name__ == '__main__':
    run_comprehensive_test()
"""

with open('scripts/test_system.py', 'w') as f:
    f.write(test_script)

print("\\n✅ Testing framework created")
print("Test script: scripts/test_system.py")'''

    @staticmethod
    def get_completion_summary() -> str:
        """Get setup completion summary"""
        return """# Setup Complete - Enhanced BibleScholarLangChain

## 🎉 System Successfully Configured

The enhanced BibleScholarLangChain system has been set up with:

### ✅ **Core Components**
- **Enhanced API Server** (port 5200) with comprehensive data integration
- **Enhanced Web UI Server** (port 5300) with modern Bootstrap interface  
- **Database Integration** with PostgreSQL and pgvector
- **License Protection** - Personal Biblical Use Only
- **Comprehensive Testing** framework

### ✅ **Key Files Created**
- `../start_servers.bat` - Enhanced server startup script
- `src/api/api_app.py` - Enhanced API server with license headers
- `web_app.py` - Enhanced web server with license protection
- `.env` - Environment configuration
- `config/config.json` - Project configuration
- `scripts/test_system.py` - System testing framework

### ✅ **License Compliance**
- **Personal Biblical Use License** implemented
- **Commercial restrictions** clearly stated  
- **Contact information**: mccoyb00@duck.com
- **License headers** on all source files

## 🚀 **Next Steps**

1. **Start the servers**:
   ```bash
   cd ..
   ./start_servers.bat
   ```

2. **Access the system**:
   - Enhanced API: http://localhost:5200
   - Enhanced Web UI: http://localhost:5300

3. **Run tests**:
   ```bash
   python scripts/test_system.py
   ```

4. **Verify functionality**:
   - Check health endpoints
   - Test Bible search functionality
   - Verify database connectivity

## 📄 **License Notice**
**🔒 Personal Biblical Use Only** - This software is licensed for free personal biblical study, research, and educational use only. Commercial use requires written permission and payment of licensing fees.

**For commercial licensing inquiries, please contact: mccoyb00@duck.com**

---

**System Version**: 2.0.0  
**Setup Date**: {timestamp}  
**License**: Personal Biblical Use Only  
**Generated by**: update_setup_notebook.py"""

def generate_notebook() -> Dict[str, Any]:
    """Generate the complete notebook with all sections"""
    
    generator = NotebookGenerator()
    
    # Main header and overview
    generator.add_markdown(ContentSections.get_header_content())
    
    # Step 1: Environment Setup
    generator.add_section_header(
        "Environment Setup", 
        "Configure the project structure and Python environment"
    )
    generator.add_code(ContentSections.get_environment_setup())
    
    # Step 2: Database Configuration
    generator.add_section_header(
        "Database Configuration", 
        "Set up database connection and verify core tables"
    )
    generator.add_code(ContentSections.get_database_setup())
    
    # Step 3: Server Configuration
    generator.add_section_header(
        "Server Configuration", 
        "Create startup scripts and configuration files"
    )
    generator.add_code(ContentSections.get_server_setup())
    
    # Step 4: Enhanced API Server
    generator.add_section_header(
        "Enhanced API Server", 
        "Create the licensed API server with comprehensive integration"
    )
    generator.add_code(ContentSections.get_api_server_code())
    
    # Step 5: Enhanced Web Server
    generator.add_section_header(
        "Enhanced Web UI Server", 
        "Create the licensed web interface with modern UI"
    )
    generator.add_code(ContentSections.get_web_server_code())
    
    # Step 6: Testing and Validation
    generator.add_section_header(
        "Testing and Validation", 
        "Test system components and create testing framework"
    )
    generator.add_code(ContentSections.get_testing_code())
    
    # Final completion summary
    generator.add_section_header("Setup Complete")
    completion_content = ContentSections.get_completion_summary().format(
        timestamp=datetime.now().isoformat()
    )
    generator.add_markdown(completion_content)
    
    # Create notebook structure
    notebook = {
        "cells": generator.cells,
        "metadata": {
            "kernelspec": {
                "display_name": "BSPclean",
                "language": "python",
                "name": "python3"
            },
            "language_info": {
                "codemirror_mode": {"name": "ipython", "version": 3},
                "file_extension": ".py",
                "mimetype": "text/x-python",
                "name": "python",
                "nbconvert_exporter": "python",
                "pygments_lexer": "ipython3",
                "version": PYTHON_VERSION
            }
        },
        "nbformat": 4,
        "nbformat_minor": 4
    }
    
    return notebook

class NotebookManager:
    """Handles notebook file operations"""
    
    @staticmethod
    def save_notebook(notebook: Dict[str, Any], path: str) -> None:
        """Save the notebook to a file with proper encoding"""
        try:
            with open(path, 'w', encoding='utf-8') as f:
                json.dump(notebook, f, indent=2, ensure_ascii=False)
            print(f"✅ Notebook saved to {path}")
        except Exception as e:
            print(f"❌ Error saving notebook: {e}")
            raise
    
    @staticmethod
    def validate_notebook(path: str) -> bool:
        """Validate that the notebook file is properly formatted"""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Check required fields
            required_fields = ['cells', 'metadata', 'nbformat', 'nbformat_minor']
            for field in required_fields:
                if field not in data:
                    print(f"❌ Missing required field: {field}")
                    return False
            
            # Check cells structure
            if not isinstance(data['cells'], list):
                print("❌ Cells must be a list")
                return False
            
            print(f"✅ Notebook validation passed ({len(data['cells'])} cells)")
            return True
            
        except Exception as e:
            print(f"❌ Notebook validation failed: {e}")
            return False

def main():
    """Main function to generate the setup notebook"""
    
    print("="*60)
    print("BibleScholarLangChain Setup Notebook Generator")
    print("Enhanced Edition with License Protection")
    print("="*60)
    
    try:
        # Generate notebook
        print("🔧 Generating comprehensive setup notebook...")
        notebook = generate_notebook()
        
        # Save notebook
        print("💾 Saving notebook...")
        NotebookManager.save_notebook(notebook, NOTEBOOK_PATH)
        
        # Validate notebook
        print("✅ Validating notebook structure...")
        if NotebookManager.validate_notebook(NOTEBOOK_PATH):
            print("\n🎉 SUCCESS!")
            print(f"Setup notebook generated: {NOTEBOOK_PATH}")
            print(f"Cells created: {len(notebook['cells'])}")
            print("\n📋 Usage:")
            print("1. Open setup.ipynb in Jupyter/VS Code")
            print("2. Run cells sequentially")  
            print("3. Follow setup instructions")
            print("\n📄 License: Personal Biblical Use Only")
            print("📧 Contact: mccoyb00@duck.com")
        else:
            print("❌ Notebook validation failed")
            return 1
            
    except Exception as e:
        print(f"❌ Error generating notebook: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main()) 